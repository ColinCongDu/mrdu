import{_ as i,c as a,o as t,ae as e}from"./chunks/framework.CMFi8ROq.js";const u=JSON.parse('{"title":"tsconfig 配置文件","description":"","frontmatter":{},"headers":[],"relativePath":"note/base/typescript/tsconfig.md","filePath":"note/base/typescript/tsconfig.md","lastUpdated":1768989984000}'),l={name:"note/base/typescript/tsconfig.md"};function o(n,s,p,c,h,d){return t(),a("div",null,s[0]||(s[0]=[e(`<h1 id="tsconfig-配置文件" tabindex="-1">tsconfig 配置文件 <a class="header-anchor" href="#tsconfig-配置文件" aria-label="Permalink to &quot;tsconfig 配置文件&quot;">​</a></h1><p>tsconfig.json 是 typescript 的配置文件，该文件所在的目录表示当前目录是 typescript 项目的根目录。使用 tsconfig.json 最重要的有两个目的：</p><ul><li>指定待编译的文件。</li><li>配置编译选项。</li></ul><p>当然，该配置文件也可以是其他名字，但你必须显式其路径。它有两种使用方式：</p><ul><li>运行 tsc 命令时，通过<code>--project</code>或者<code>-p</code> 命令行选项显示指定 tsconfig.json 文件的目录，或者直接指定.配置 json 文件的路径。</li><li>若运行 tsc 命令时没有显式指定该文件或文件目录的时候，编译器会从当前目录开始，并向父目录开始查找该文件。</li></ul><p>tsconfig.json 文件主要包含 5 个大的配置项：&quot;files&quot;、&quot;include&quot;、&quot;exclude&quot;、&quot;compilerOptions&quot;、&quot;extends&quot;。</p><h2 id="基本配置项" tabindex="-1">基本配置项 <a class="header-anchor" href="#基本配置项" aria-label="Permalink to &quot;基本配置项&quot;">​</a></h2><ul><li>files 需要编译的单个文件的列表。可以使用相对或者绝对路径。当然，该配置项只适用于引入少量文件。</li></ul><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	&quot;files&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./utils/typeHeler.ts&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;test.ts&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>include 需要编译的文件或目录。它支持 global 通配符。</li></ul><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	&quot;include&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;src&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;scripts/**/*&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;test/*&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>exclude 需要排除的文件或目录，仅用于更排除掉<code>&quot;include&quot;</code>设置中包含的文件。虽然它能够过滤掉<code>&quot;include&quot;</code>引入的文件，但是<code>files</code>和<code>&lt;reference&gt;</code>明确指定的文件却会始终包含在内。默认情况下回排除掉 <code>node_modules</code>、<code>bower_components</code>、<code>jspn_packages</code>目录和<code>&lt;outDir&gt;</code>目录。</li></ul><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;exclude&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        &quot;dist&quot;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        &quot;node_&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p>默认情况下，编译器包含需要编译的目录及子目录下所有的 TypeScript 文件（<code>.ts</code>、<code>.d.ts</code>、<code>.tsx</code>）文件。</p><p><code>&quot;include&quot;</code>和<code>&quot;exclude&quot;</code>配置时可以使用 globa 通配符：</p><ul><li><code>*</code>匹配 0 或多个字符（不包含目录分隔符）</li><li><code>?</code>匹配任意一个字符（不包含目录分隔符）</li><li><code>**/</code>递归匹配任意子目录</li></ul></blockquote><ul><li>extends</li></ul><h2 id="compolieroptions" tabindex="-1">compolierOptions <a class="header-anchor" href="#compolieroptions" aria-label="Permalink to &quot;compolierOptions&quot;">​</a></h2><h3 id="类型检查" tabindex="-1">类型检查 <a class="header-anchor" href="#类型检查" aria-label="Permalink to &quot;类型检查&quot;">​</a></h3><ul><li><p>allowUnreachableCode（允许不可访问的代码） 不可访问的代码即那些永远不可能被执行的代码。allowUnreachable 配置项决定我们如何处理那些永远不会被执行的代码。它有三个值：</p><ul><li>undefined（默认）：编译时抛出建议作为 wraning。</li><li>true：不可访问的代码会被忽略掉，即允许存在不可访问的代码。</li><li>false：抛出一个不可访问代码的相关编译错误。</li></ul></li><li><p>allowUnusedLabels（允许未使用的标签） 虽然通常标签在 javascript 中使用非常少。但是 ts 依然提供了针对标签的配置选项。它也有三个值：</p><ul><li>undefined（默认）：编译时在编辑器中抛出建议作为 warning。</li><li>true：未被使用的标签会被忽略掉，允许存在未被使用的标签。</li><li>false：抛出一个关于存在未被使用的标签的错误。</li></ul></li><li><p>alwaysStrict 确保文件使用严格模式进行解析。</p></li></ul><h4 id="exactoptionalpropertytypes-精确的可选属性类型" tabindex="-1">exactOptionalPropertyTypes（精确的可选属性类型） <a class="header-anchor" href="#exactoptionalpropertytypes-精确的可选属性类型" aria-label="Permalink to &quot;exactOptionalPropertyTypes（精确的可选属性类型）&quot;">​</a></h4><h4 id="nofallthroughcasesinswitch-在-switch-没有落空-case" tabindex="-1">noFallthroughCasesInSwitch（在 Switch 没有落空 Case） <a class="header-anchor" href="#nofallthroughcasesinswitch-在-switch-没有落空-case" aria-label="Permalink to &quot;noFallthroughCasesInSwitch（在 Switch 没有落空 Case）&quot;">​</a></h4><h4 id="maproot" tabindex="-1">mapRoot <a class="header-anchor" href="#maproot" aria-label="Permalink to &quot;mapRoot&quot;">​</a></h4><h4 id="moduleresolution" tabindex="-1">moduleResolution <a class="header-anchor" href="#moduleresolution" aria-label="Permalink to &quot;moduleResolution&quot;">​</a></h4>`,22)]))}const k=i(l,[["render",o]]);export{u as __pageData,k as default};
