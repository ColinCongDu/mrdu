import{_ as e,c as t,o as i,ae as r}from"./chunks/framework.CMFi8ROq.js";const s="/mrdu/assets/TS%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.ClArFJT3.png",p="/mrdu/assets/ts%E7%BB%84%E6%88%90.C0ZSjjFd.png",l="/mrdu/assets/TS%E5%8C%85%E7%BB%84%E6%88%90.B8TXQ8MO.png",y=JSON.parse('{"title":"快速上手","description":"","frontmatter":{},"headers":[],"relativePath":"note/base/typescript/快速上手.md","filePath":"note/base/typescript/快速上手.md","lastUpdated":1769076434000}'),o={name:"note/base/typescript/快速上手.md"};function c(d,a,n,h,S,u){return i(),t("div",null,a[0]||(a[0]=[r('<h1 id="快速上手" tabindex="-1">快速上手 <a class="header-anchor" href="#快速上手" aria-label="Permalink to &quot;快速上手&quot;">​</a></h1><h2 id="typescript的作用" tabindex="-1">TypeScript的作用 <a class="header-anchor" href="#typescript的作用" aria-label="Permalink to &quot;TypeScript的作用&quot;">​</a></h2><p>JavaScript 自诞生起，就运行于浏览器端，最初只是用来处理一些简单的用户交互，如表单验证等操作，而不是每次都提交给服务端验证。所以它不需要设计的特别复杂，只进行了简单的类型定义。</p><p>随着浏览器性能的提升，能够满足更加复杂的交互和承载更多的业务需求，所以基于 JavaScript 开发的项目也就越来越复杂，而复杂的项目也就意味着更多的Bug😄。</p><p>JavaScript 作为弱类型的语言，是被解释执行的，缺少运行前的类型检查，只能在运行时检查并找到类型错误。对于中/大型项目，由类型引发的错误非常多，甚至可以说是线上 Bug 的“重灾区”，核心原因就是 js 作为弱类型语言，没有编译器的类型校验。</p><p>为了弥补 JavaScript 类型上缺失，TypeScript 诞生了😊！其<a href="https://www.typescriptlang.org/" target="_blank" rel="noreferrer">官网</a>中写的很明确：<strong>TypeScript 的目标就是成为 JavaScript 的类型检查器</strong>。你可以把它当做一门全新的语言看待，它定义了一套完整的类型系统，并在“编译期”进行类型检查，只不过它把 JavaScript 作为“编译期”的产物了。</p><p><img src="'+s+'" alt="TypeScript编译过程"></p><h2 id="typescript的组成" tabindex="-1">TypeScript的组成 <a class="header-anchor" href="#typescript的组成" aria-label="Permalink to &quot;TypeScript的组成&quot;">​</a></h2><p>个人从架构的角度，把 TypeScript 的分成了下面三个层级。</p><p><img src="'+p+'" alt="TypeScript组成"></p><h5 id="语言层" tabindex="-1">语言层 <a class="header-anchor" href="#语言层" aria-label="Permalink to &quot;语言层&quot;">​</a></h5><p>虽然 TypeScript 最终是被编译成 JavaScript 执行的，但它依然是一门全新的语言。从学习的角度来讲，存在着不小的成本。这里仅说明它有哪些特点，在后续的章节中，我们再详细深入讲解它的语法。</p><ul><li>对比 Java 等强类型语言，它定义了一套完整的语法，包括变量声明、函数声明、类声明、接口声明、函数重载等。</li><li>它支持 JavaScript 的所有语法，所以被称为 JavaScript 的超集。也就是说，任何合法的JavaScript 代码，都是合法的 TypeScript 代码。</li></ul><h5 id="编译器-工具链层" tabindex="-1">编译器 &amp; 工具链层： <a class="header-anchor" href="#编译器-工具链层" aria-label="Permalink to &quot;编译器 &amp; 工具链层：&quot;">​</a></h5><p>如果是单纯的定义语法，那 TypeScript 实际上是做不了什么的，所以必须要有与之配套的工具，才能把它实际使用起来。</p><ul><li>编译器：作用是把 TypeScript 代码编译成 JavaScript 代码。</li><li>语言服务：提供类型推断、代码补全、代码导航、重构等功能。</li><li>工程配置：配置 TypeScript 项目的编译选项、输出目录、模块系统等。</li></ul><h5 id="生态融合层" tabindex="-1">生态融合层 <a class="header-anchor" href="#生态融合层" aria-label="Permalink to &quot;生态融合层&quot;">​</a></h5><p>TypeScript不是用来取代JavaScript的，世界已经是 JavaScript 的了，TypeScript 必须兼容整个世界。</p><h2 id="安装" tabindex="-1">安装 <a class="header-anchor" href="#安装" aria-label="Permalink to &quot;安装&quot;">​</a></h2><p>我们可以通过npm安装TypeScript，并且应该作为开发依赖被安装，它的本质是“转译器”，在运行时并不存在。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> typescript</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --save-dev</span></span></code></pre></div><p>“ typescript ”包，包含下面几个部分：</p><p><img src="'+l+'" alt="ts包组成"></p><h5 id="命令行执行工具" tabindex="-1">命令行执行工具 <a class="header-anchor" href="#命令行执行工具" aria-label="Permalink to &quot;命令行执行工具&quot;">​</a></h5><p>这是 tsc 时真正运行的部分。它们通常位于 bin/ 目录下：</p><ul><li><code>tsc</code> : TypeScript编译器的终端入口, 运行 <code>npx tsc</code> 或 <code>tsc</code> 时实际调用的文件。</li><li><code>tsserver</code> : TypeScript语言服务进程。这是IDE(如VS Code)背后的英雄，基于LSP（语言服务协议）与编辑器通信。它负责提供** 语法高亮、代码补全、实时错误提示 **。</li></ul><h5 id="标准库声明文件" tabindex="-1">标准库声明文件 <a class="header-anchor" href="#标准库声明文件" aria-label="Permalink to &quot;标准库声明文件&quot;">​</a></h5><p>这是TypeScript内置的类型库，是类型系统的基础。ts 必须知道 js 的内置对象长什么样。</p><ul><li>作用：为js内置对象（如 Array, Promise, window, Document 等）提供类型声明，无需你手动定义就可以做类型检查。</li><li>分类： <ul><li>按js版本：<code>lib.es5.d.ts</code> (ES5)、 <code>lib.es2015.d.ts</code> （ES6）、 <code>lib.esnext.d.ts</code>（最新 ES 特性）；</li><li>按运行环境分：<code>lib.dom.d.ts</code> （浏览器环境）、 <code>lib.node.d.ts</code> (Node.js环境)、 <code>lib.webworker.d.ts</code> （WebWorker）；</li></ul></li><li>使用方式： ts会根据tsconfig.json中的target和lib配置自动加载对象的 <code>.d.ts</code> 文件。（比如 <code>target: ES6</code> 会自动加载 <code>lib.es6.d.ts</code> ）.</li></ul><h5 id="编译器核心与-api" tabindex="-1">编译器核心与 API <a class="header-anchor" href="#编译器核心与-api" aria-label="Permalink to &quot;编译器核心与 API&quot;">​</a></h5><p>这是整个TypeScript包的核心，这是整个包的底层逻辑实现：</p><ul><li><strong>核心内容</strong>：包含 TS 编译的全流程逻辑 —— 词法分析、语法分析、类型检查、AST 转换、代码发射（生成 JS），以及类型系统的所有核心逻辑（类型推断、类型收窄、类型兼容性判断等）。</li><li><strong>无独立拆分</strong>：TS 的编译器逻辑被打包成一个单文件（typescript.lib.js），tsc和tsserver都会加载这个文件</li></ul><h5 id="语言服务" tabindex="-1">语言服务 <a class="header-anchor" href="#语言服务" aria-label="Permalink to &quot;语言服务&quot;">​</a></h5><p>这一部分是编辑器智能提示、跳转、重构的真正源头。</p><ul><li><strong>实时分析</strong>：当你在编辑器里打字时，tsserver 会增量解析你的代码，计算语法树（AST）。</li><li><strong>通信协议</strong>：它通过 LSP (Language Server Protocol) 的变体与编辑器通信。</li></ul>',35)]))}const m=e(o,[["render",c]]);export{y as __pageData,m as default};
