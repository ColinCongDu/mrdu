import{_ as a,c as o,o as l,ae as i}from"./chunks/framework.CMFi8ROq.js";const u=JSON.parse('{"title":"进程模型","description":"","frontmatter":{},"headers":[],"relativePath":"note/base/node/进程模型.md","filePath":"note/base/node/进程模型.md","lastUpdated":1757926322000}'),r={name:"note/base/node/进程模型.md"};function t(d,e,n,s,p,h){return l(),o("div",null,e[0]||(e[0]=[i('<h1 id="进程模型" tabindex="-1">进程模型 <a class="header-anchor" href="#进程模型" aria-label="Permalink to &quot;进程模型&quot;">​</a></h1><p>在学习node.js的进程模型之前，我们先抛出几个问题:</p><ol><li>node.js的进程模型和传统的多线程服务（Java、Apache、.NET）相比有什么区别？</li><li>我们通常说node.js具有异步事件驱动、非阻塞IO、单线程的特点，所以node.js具有超强的高并发能力的优势。为什么异步IO就具有高并发的优势呢？</li><li>为什么说node.js适合IO密集型任务，而不适合CPU密集型任务？</li><li>既然node.js是单线程的，那它是如何实现高并发的呢？</li></ol><p>带着这些问题，我们一步一步来分析node.js的进程模型。</p><h2 id="传统服务器的进程模型" tabindex="-1">传统服务器的进程模型 <a class="header-anchor" href="#传统服务器的进程模型" aria-label="Permalink to &quot;传统服务器的进程模型&quot;">​</a></h2><p>以Java Servlet 容器（Tomcat）、Apache HTTP Server（Prefork/Worker）、.NET ASP.NET Core Kestrel 为例，它们大多遵循”多进程+多线程（线程池）“的模型。</p><p>运行方式：</p><ol><li>每个请求需要一个<strong>独立线程</strong>来处理，如果有N个并发请求，就需要N个线程处理。</li><li>I/O是阻塞的，线程需要等待I/O操作(如数据库查询、文件读写等)完成，才能继续执行后续代码。</li></ol><p>实现方式：</p><ol><li>进程模型：通常会有一个主进程监听端口，然后fork/启动多个 <code>worker</code> 进程。</li><li>线程模型：每个 <code>worker</code> 进程内有一个线程池，用来分配给请求。</li></ol><p>优点</p><ol><li>每个请求都有独立线程, 逻辑简单，不需要自己考虑事件循环。</li><li>适合 CPU 密集型任务，多核利用率高。</li></ol><p>缺点</p><ol><li>高并发时需要大量线程，线程上下文切换开销大。</li><li>每个线程的栈内存占用（通常 512KB~1MB），1万并发就可能吃掉 10GB 内存。</li><li>阻塞 I/O 会导致线程被挂起，降低吞吐。</li></ol><h2 id="node-js的进程模型" tabindex="-1">node.js的进程模型 <a class="header-anchor" href="#node-js的进程模型" aria-label="Permalink to &quot;node.js的进程模型&quot;">​</a></h2><p>Node.js 的进程模型是“单线程事件循环 + libuv 线程池 + 多进程扩展”，这种模型非常适合高并发 I/O 应用。</p><p>运行方式:</p><ol><li>不会为每个请求创建一个独立的线程，只有一个主线程处理请求，。所以有请求都在, 同一个事件循环（单线程） 中排队、调度。</li><li>非阻塞I/O，所有的I/O操作都在<code>libuv</code>线程池（4个线程）中执行，不会阻塞主线程。</li></ol><h2 id="node-js-一个线程处理所有请求-会不会阻塞" tabindex="-1">Node.js 一个线程处理所有请求，会不会阻塞？ <a class="header-anchor" href="#node-js-一个线程处理所有请求-会不会阻塞" aria-label="Permalink to &quot;Node.js 一个线程处理所有请求，会不会阻塞？&quot;">​</a></h2><p>这是很多人第一次接触 Node.js 的时候最疑惑的地方。要分两种情况， 我们拆开来说。</p><h3 id="i-o-密集型请求-绝大多数-web-应用" tabindex="-1">I/O 密集型请求（绝大多数 Web 应用） <a class="header-anchor" href="#i-o-密集型请求-绝大多数-web-应用" aria-label="Permalink to &quot;I/O 密集型请求（绝大多数 Web 应用）&quot;">​</a></h3><ul><li>Node.js 主线程接到请求后，不会自己去做 I/O（例如读文件、查数据库、调用外部API）。</li><li>它会把这些耗时任务交给 libuv 的线程池 或 操作系统内核 去做。</li><li>主线程只负责记录一下“有个请求在等结果”，然后立刻去处理下一个请求。</li><li>当 I/O 完成时，结果会回调到事件循环，主线程再调用对应的回调函数。</li></ul><p>所以即使有成千上万的并发请求，主线程也不会被阻塞，只是多了很多“待处理的回调”。 这就是Node.js可以轻松支撑10万级别并发连接的原因。</p><h3 id="cpu-密集型请求-例如计算、加密、压缩等" tabindex="-1">CPU 密集型请求（例如计算、加密、压缩等） <a class="header-anchor" href="#cpu-密集型请求-例如计算、加密、压缩等" aria-label="Permalink to &quot;CPU 密集型请求（例如计算、加密、压缩等）&quot;">​</a></h3><ul><li>如果主线程自己在跑耗时的 CPU 计算（比如循环处理大文件、加密、视频转码）， 那么事件循环会被卡住，其他请求就得等。</li><li>这时 Node.js 的“单线程模型”确实会成为瓶颈。</li></ul><p>这也就是为什么会说node.js适合IO密集型任务，而不适合CPU密集型任务的原因。</p><h2 id="" tabindex="-1"><a class="header-anchor" href="#" aria-label="Permalink to &quot;&quot;">​</a></h2>',27)]))}const _=a(r,[["render",t]]);export{u as __pageData,_ as default};
