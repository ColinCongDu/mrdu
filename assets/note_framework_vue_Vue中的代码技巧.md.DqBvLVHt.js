import{_ as e,c as i,o as s,ae as t}from"./chunks/framework.CMFi8ROq.js";const u=JSON.parse('{"title":"Vue中的代码技巧","description":"","frontmatter":{},"headers":[],"relativePath":"note/framework/vue/Vue中的代码技巧.md","filePath":"note/framework/vue/Vue中的代码技巧.md","lastUpdated":1739977780000}'),h={name:"note/framework/vue/Vue中的代码技巧.md"};function n(r,a,l,o,d,p){return s(),i("div",null,a[0]||(a[0]=[t(`<h1 id="vue中的代码技巧" tabindex="-1">Vue中的代码技巧 <a class="header-anchor" href="#vue中的代码技巧" aria-label="Permalink to &quot;Vue中的代码技巧&quot;">​</a></h1><h2 id="问答篇" tabindex="-1">问答篇 <a class="header-anchor" href="#问答篇" aria-label="Permalink to &quot;问答篇&quot;">​</a></h2><h3 id="为什么vue中的data必须是函数" tabindex="-1">为什么vue中的data必须是函数？ <a class="header-anchor" href="#为什么vue中的data必须是函数" aria-label="Permalink to &quot;为什么vue中的data必须是函数？&quot;">​</a></h3><p>为了组件的复用。如果data是一个对象，那么当组件在多个地方复用时，data都会指向一个对象，造成干扰。而data如果是一个函数，则返回的对象会指向不同的地址。就不会造成干扰。</p><h2 id="技巧篇" tabindex="-1">技巧篇 <a class="header-anchor" href="#技巧篇" aria-label="Permalink to &quot;技巧篇&quot;">​</a></h2><h3 id="实例化判断" tabindex="-1">实例化判断 <a class="header-anchor" href="#实例化判断" aria-label="Permalink to &quot;实例化判断&quot;">​</a></h3><p>在Vue的构造函数里，开头有这样一段代码。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> instanceof</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    warn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Vue is a constructor and should be called with the &#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39; keyword)</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>我们知道instanceof 运算符用于判断“构造函数的prototype属性是否出现在指定对象的原型链上”，在这里就可以判断this是不是Vue这个构造函数的实例。而一个函数内部的this指向是由函数的调用者决定的，函数由谁调用则this就指向谁。所以这里就可以判断this是通过new关键字调用，还是直接通过Vue()调用。当不是通过new关键字去创建Vue实例的时候就发出errors。</p><h2 id="工具类篇" tabindex="-1">工具类篇 <a class="header-anchor" href="#工具类篇" aria-label="Permalink to &quot;工具类篇&quot;">​</a></h2><h3 id="缓存函数及工程中的缓存思想" tabindex="-1">缓存函数及工程中的缓存思想 <a class="header-anchor" href="#缓存函数及工程中的缓存思想" aria-label="Permalink to &quot;缓存函数及工程中的缓存思想&quot;">​</a></h3><h3 id="连字符拼接的字符串转化为驼峰写法" tabindex="-1">连字符拼接的字符串转化为驼峰写法 <a class="header-anchor" href="#连字符拼接的字符串转化为驼峰写法" aria-label="Permalink to &quot;连字符拼接的字符串转化为驼峰写法&quot;">​</a></h3>`,12)]))}const c=e(h,[["render",n]]);export{u as __pageData,c as default};
