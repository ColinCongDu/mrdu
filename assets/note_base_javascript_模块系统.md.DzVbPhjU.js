import{_ as i,c as a,o as n,ae as l}from"./chunks/framework.CMFi8ROq.js";const o=JSON.parse('{"title":"模块系统","description":"","frontmatter":{},"headers":[],"relativePath":"note/base/javascript/模块系统.md","filePath":"note/base/javascript/模块系统.md","lastUpdated":1739977780000}'),h={name:"note/base/javascript/模块系统.md"};function t(p,s,k,e,d,r){return n(),a("div",null,s[0]||(s[0]=[l(`<h1 id="模块系统" tabindex="-1">模块系统 <a class="header-anchor" href="#模块系统" aria-label="Permalink to &quot;模块系统&quot;">​</a></h1><h2 id="脚本加载的模式" tabindex="-1">脚本加载的模式 <a class="header-anchor" href="#脚本加载的模式" aria-label="Permalink to &quot;脚本加载的模式&quot;">​</a></h2><p>在了解模块系统之前，我们先聊聊几个概念：同步加载、异步加载、预加载和懒加载。这有助于你了解，为什么会出现这么多模块化解决方案。同步加载和异步加载是根据宿主环境对于资源请求的方式进行区分，而预加载和懒加载则是根据资源的请求时机进行区分。当然，这里的宿主环境通常指的是浏览器，但随着Node.js等轻量级服务器的出现，就不仅仅指的是浏览器了。</p><ul><li>同步加载：也被称为阻塞模式加载，这会使得宿主环境暂停对于其他资源的处理，直到当前资源文件加载完毕。例如浏览器在JS文件加载并执行完毕前，会停止页面的渲染。</li><li>异步加载：也被称为非阻塞模式加载。即宿主环境在加载当前文件的同时，同时还会处理其它资源。例如在浏览器中，当JS使用异步模式加载时，不会暂停页面的渲染。</li><li>预加载：指的是宿主环境会预测用户的下一步行为，并提前加载下一步行为所需要的内容。比如当我们浏览器新闻网站时，即使突然断网，你依然可以点进某一条新闻，查看该条新闻的详细内容，即使这条新闻你从未打开过。</li><li>懒加载：指的是宿主环境并不会提前将所有资源下载完毕，而是在用户执行下一步操作的时候，才会去真正加载。比如我们在逛电商网站时，只有某个商品被滚动到窗口内，才会去加载当前商品的图片等信息。</li></ul><p>当然，因为本篇文章，主要讨论的JavaScript的模块化，所以无论是同/异步加载，还是预/懒加载，其被加载的资源都指的是JavaScript文件。</p><h3 id="浏览器中的脚本加载" tabindex="-1">浏览器中的脚本加载 <a class="header-anchor" href="#浏览器中的脚本加载" aria-label="Permalink to &quot;浏览器中的脚本加载&quot;">​</a></h3><p>在HTML中通常使用<code>&lt;script&gt;</code>标签加载JavaScript脚本。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;text/javascript&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./a.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;text/javascript&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./b.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><ul><li><p>在默认情况下，浏览器会按照文档顺序同步加载JavaScript脚本。这会阻塞浏览器的渲染进程，直到脚本加载并执行完毕，再继续进行渲染。这是因为浏览器并不确定加载的脚本会不会对DOM树产生操作，如果会就需要重新渲染页面，造成资源浪费。但是当脚本体积很大，下载和执行的时间变长，就会造成页面的卡顿、或者首屏白屏等，导致不友好的体验。</p></li><li><p>在<code>&lt;script&gt;</code>标签添加了<code>defer</code>或<code>async</code>属性会使得资源异步加载。即渲染引擎遇到该标签就会开始下载脚本，但不会等待它下载和执行。 不同的是：defer会把脚本的执行推迟到页面渲染结束，而async会在脚本下载完成后，会中断页面的渲染，待该脚本执行完毕，再继续渲染，</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;text/javascript&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./a.js&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">// 或</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;text/javascript&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./b.js&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div></li></ul><h2 id="前端为什么需要模块化" tabindex="-1">前端为什么需要模块化 <a class="header-anchor" href="#前端为什么需要模块化" aria-label="Permalink to &quot;前端为什么需要模块化&quot;">​</a></h2><p>在了解前端为什么需要模块化之前，我们需要先了解一下什么是模块化。当我们说模块化的时候，通常指的高度解耦、存储在模块中的不同功能块。</p><p>在代码层面，随着浏览器性能的提升, 业务的复杂性带来了代码量的提升。同时，随着javascript社区的活跃，出现了大量可复用的代码，因此急需一个模块化解决方案来提升代码的组织管理方式。在某些情况下，松散耦合的模块能够使得程序更易于维护；同时对各自模块的封装，并对外暴露接口，更利于第三方库的分享和使用；在语言层面，防止代码量过大，导致的命名冲突；使用合理的代码加载方案，解决业务复杂度提升带来的性能问题。</p><h2 id="创建模块化方案可能遇到的问题" tabindex="-1">创建模块化方案可能遇到的问题 <a class="header-anchor" href="#创建模块化方案可能遇到的问题" aria-label="Permalink to &quot;创建模块化方案可能遇到的问题&quot;">​</a></h2><ol><li>如何给模块一个唯一标识。</li><li>如何能够在不污染外部代码的情况下封装模块。</li><li>如何在不增加全局变量的情况下把模块暴露出去。</li><li>模块间应该如何相互引用。</li></ol><h2 id="模块化发展历史" tabindex="-1">模块化发展历史 <a class="header-anchor" href="#模块化发展历史" aria-label="Permalink to &quot;模块化发展历史&quot;">​</a></h2><p>了解模块化的发展过程及其在各个阶段遇到的问题，更有利于理解当前模块化的使用和学习。</p><ul><li><p>1995年5月，JavaScript问世。最初的JavaScript版本迭代中，并未提供干净的、有组织的模块方法。</p><ul><li>2005年诞生的ajax，使得浏览器请求额外的服务端数据而不需要刷新页面，极大的提升了用户体验。</li></ul></li><li><p>2006年jQuery诞生了。John Resig创造性的使用IIEF(立即执行函数表达式)和闭包的特性来封装代码。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">root</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    root.jQuery </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root.$ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> jQuery;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})(window);</span></span></code></pre></div><ul><li>2008年，Google Chrome浏览器的发布，开启了浏览器多进程的时代。浏览器性能的巨大提升，使得浏览器能够承载更复杂逻辑，进一步促进了前端业务的复杂性，从而使得模块化的需要更加迫切。</li></ul></li><li><p>2009年，Mozilla工程师Kevin Dangoor发起了ServerJS的模块化规范，同年8月，该规范改名为CommonJS。</p><ul><li><p>2009年5月，Ryan Dahl发布了一个基于Chrome V8引擎开发的轻量级服务器，并发布了一个包管理器NPM（Node Module Manager），其采用了基于CommonJS模块化解决方案。</p><blockquote><p>CommonJS规范最初应用到服务端的，自然而然的便有人想到，如何模块化解决方案应用到浏览器中。但如何将其应用到浏览器中形成了巨大争议，并因此形成了几个流派。</p><ul><li>Modules/1.0派：这派认为，既然该方案在服务端应用有了很好的实践经验，那只要把它移植到浏览器中就好了，在浏览器加载模块之前，将代码转化为浏览器能够运行的代码就好了。我们可以称这派为“保守派”，</li><li>Modules/Asyc派：这派认为，由于浏览器环境和服务端环境的巨大差异，就不应该在该方案上进行小修小补，而是应该遵循浏览器的特点，实现一个异步模块加载方案，这一派我们称之为“激进派”。</li><li>Modules/2.0派：这派是“温和派”，他们认为既不应该彻底沿用CommonJS的方案，也不应该随便放弃，而是尽可能保持一致。</li></ul></blockquote></li></ul></li><li><p>2009年9月，激进派的James Burke开发出了RequireJS模块加载器，以实践证明自己的观点，并在2011年2月，发布了AMD标准规范。ADM起源于CommonJS模块格式的草案规范的讨论中，但是由于Commonjs项目组成员之间为达成一致，2009年年底，在James Bureke等人的带领下，激进派离开CommonJS社区，自立门户。该格式的进一步开发就转到了AMD JS工作组。</p></li><li><p>2011年4月，阿里巴巴前端开发工程师玉伯，在给RequireJS提出剪辑被拒绝之后，开发了SeaJS模块加载器，并提出了CMD这一标准规范。</p></li><li><p>2014年9月，美籍华裔Homa Wong提交了UMD第一个版本的代码，它本质上并不是一个真正的模块化解决方案，而是CommonJS和AMD的结合体。</p></li><li><p>20016年6月，ECMAScript6.0在经过两年的讨论后，终于通过了国际标准，并首次在语言层面引入了模块化解决方案:ES Module。在JavaScript诞生的26年后，JavaScript终于迎来了自己的模块化解决方案。</p><blockquote><p>值得注意的是，无论是CommonJS还是AMD，亦或者UMD，它们都属于模块化方案的标准，而真正的实现依赖于模块加载器。当然，抛开历史不谈，由于Webpack、Babel等工具的兴起去，前端开发工程师已经不需要在实现中考虑采用哪种方案了，习惯写哪一种就写哪一种，最终都可以通过工具转化为任意一种实现。</p></blockquote></li></ul><h2 id="模块化解决方案介绍" tabindex="-1">模块化解决方案介绍 <a class="header-anchor" href="#模块化解决方案介绍" aria-label="Permalink to &quot;模块化解决方案介绍&quot;">​</a></h2><p>上面介绍了模块化方案的发展历史，下面将介绍各个方案的实现，并介绍各个模块化方案的优缺点，其方案的缺点正是促成新模块化方案出现的原因。</p><h3 id="commmonjs" tabindex="-1">CommmonJS <a class="header-anchor" href="#commmonjs" aria-label="Permalink to &quot;CommmonJS&quot;">​</a></h3><p><a href="http://www.commonjs.org/" target="_blank" rel="noreferrer">CommonJS</a>规范概述了一个<strong>同步声明</strong>的模块定义，其目标环境是服务端。其使用require()函数加载依赖，并使用exports对象暴露自己的公共API。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> moduleB</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./moduleB&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   stuff: moduleB.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sutff</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1、模块的引入使用相对路径。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> moduleA</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./moduleA&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2、通常会把加载的模块赋值给一个变量，但这不是必须的。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> moduleA</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./moduleA&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 或</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./moduleA&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 3、模块多个模块引入只会执行一次，即模块永远是单例。即模块第一次加载会被缓存，后续加载会取得缓存。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./moduleA&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./moduleA&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 4、模块的顺序，按照其在代码中出现的顺序。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./moduleA&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./moduleB&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> c</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./moduleC&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 5、模块的加载是同步的。当前如果moduleA在之前加载过，在loadCondtion之后，只是暴露了一下命名空间而已。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (loadCondition) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./moduleA&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>模块的导出也有多种实现方式。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1、模块可以不导出任何东西，但如果有应用程序请求该模块，该模块体也会被执行。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2、模块可以导出一个实体。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;foo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 3、模块可以一次性导出多个变量。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    a: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;A&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    b: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;B&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 等价于</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;A&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;B&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 4、模块可以导出一个类实例</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {};</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><h3 id="amd-async-module-definition" tabindex="-1">AMD （Async Module Definition） <a class="header-anchor" href="#amd-async-module-definition" aria-label="Permalink to &quot;AMD （Async Module Definition）&quot;">​</a></h3><p>AMD(异步模块定义)的目标环境是浏览器。AMD的核心是用函数包装模块定义，其是异步、提前加载，但在兼容CommonJS的基础之上，也可以实现懒加载。其定义了define()和require()两个函数进行模块的定义和引入。</p><p>define函数的定义的方式</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>/**</span></span>
<span class="line"><span> * id：可选参数。</span></span>
<span class="line"><span> * dependencies[]: 可选参数</span></span>
<span class="line"><span> * factory: </span></span>
<span class="line"><span> * /</span></span>
<span class="line"><span>define(id?, dependencies?, factory);</span></span></code></pre></div><p>模块的引入支持两种方式。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 异步加载</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">define</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(moduleA, [moduleB], </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">moduleB</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> moduleB.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stuff</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// AMD也可以定义CommonJS风格的模块, 即支持require函数和exports对象。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// AMD加载器会将其识别为AMD原生结构。动态加载即通过这种方式实现。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">define</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(moduleA, [require, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">exports</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> moduleB</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./moduleB&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        stuff: moduleB.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stuff</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h3 id="cmd-common-module-definition" tabindex="-1">CMD（Common Module Definition） <a class="header-anchor" href="#cmd-common-module-definition" aria-label="Permalink to &quot;CMD（Common Module Definition）&quot;">​</a></h3><p>CMD是阿里巴巴前端工程师玉伯开发。</p><h3 id="umd-universal-module-definition" tabindex="-1">UMD（Universal Module Definition） <a class="header-anchor" href="#umd-universal-module-definition" aria-label="Permalink to &quot;UMD（Universal Module Definition）&quot;">​</a></h3><p><a href="https://github.com/umdjs/umd" target="_blank" rel="noreferrer">UMD</a>本质上并不是一个新的模块系统，它只是为了统一CommonJS和AMD的生态系统而已，用于创建这两个系统都可以使用的模块。</p><p>UMD的实现很简单：</p><ol><li><p>先判断是否支持AMD模块格式（是否存在define函数，且define函数拥有amd属性），支持则使用AMD方式加载模块。</p></li><li><p>在判断是否支持Node模块格式（是否存在exports）,不支持严格CommonJS，存在则使用Node模块格式。</p></li><li><p>前两个都不存在，则将模块公开到全局（window或global）。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">root</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">factory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> define </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;function&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> define.amd) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        define</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;moduleB&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], factory);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typeof</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> module</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;object&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> factory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;moduleB&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        root.returnExports </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> factory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root.moduleB); </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">moduleB</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 以某种方式使用模块moduleB</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}));</span></span></code></pre></div></li></ol><h3 id="es-module" tabindex="-1">ES module <a class="header-anchor" href="#es-module" aria-label="Permalink to &quot;ES module&quot;">​</a></h3><h3 id="模块化方案比较" tabindex="-1">模块化方案比较 <a class="header-anchor" href="#模块化方案比较" aria-label="Permalink to &quot;模块化方案比较&quot;">​</a></h3><table tabindex="0"><thead><tr><th>模块方案</th><th>加载</th><th>输出</th><th>加载方式</th></tr></thead><tbody><tr><td>CommonJS</td><td></td><td></td><td></td></tr><tr><td>AMD</td><td></td><td></td><td></td></tr><tr><td>UMD</td><td></td><td></td><td></td></tr><tr><td>CMD</td><td></td><td></td><td></td></tr><tr><td>ES Module</td><td></td><td></td><td></td></tr></tbody></table><h2 id="参考链接" tabindex="-1">参考链接 <a class="header-anchor" href="#参考链接" aria-label="Permalink to &quot;参考链接&quot;">​</a></h2>`,41)]))}const g=i(h,[["render",t]]);export{o as __pageData,g as default};
