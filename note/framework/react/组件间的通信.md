# 组件间的通信

通常来说，我们会把一个页面拆分成一个个的组件去实现，当单个组件的逻辑比较复杂时，我们又会将这个组件拆分成多个子组件。这就涉及到一个问题：组件之间经常需要相互通信。比如父组件想要修改子组件的状态，或者子组件要告诉父组件有哪些状态变化。

根据组件层级之间的相对关系，我们可以划分几种通信场景：

-   父子组件通信
-   兄弟组件通信
-   跨级组件通信
-   组件全局通信

在 React 中，实现这几种通信场景，通常有下面几种方式：

-   使用`props`和回调函数通信。
    父子组件和兄弟组件间通信使用这种方式；兄弟组件使用共同的父组件作为桥梁。
-   使用`ref`通信。
    使用命令式的方式访问子组件的状态或方法、`DOM`。
-   使用`Context`通信。通常用于跨级组件通信。
-   使用`EventBus`。
    通常用于跨级组件通信。但是 React 并没有像 Vue 那样原生支持`EventBus`，需要借助`events`、`mitt`这种第三库实现。
-   使用`redux`和`react-redux`。
    React 官方提供了`redux`和`react-redux`工具进行集中式的状态管理，利用它我们也实现组件通信。我们并不会在本章节详细介绍它，在后续的`redux`模块我们再详细介绍。

## 父子组件通信

### 使用 props 和回调函数通信

这件事并没有我们想象的那么复杂。简单的讲，父组件把变量或者函数作为参数传递给子组件，这些参数被包装在一个被称为`props`的对象中。 在子组件中，就可以接收这些变量和函数，当子组件在内部调用这些函数的时候，同时可以传入一些参数，就成功的向父组件传递了信息。这样你就完成了父子组件之间的通信，假如你把父组件当做一个数据的中转站，那么你就可以同时完成兄弟组件之间的通信了。

在下面的例子中，我们演示了这种通信方式。假设我们现在有两个组件，父组件`<Counter/>`和子组件`<Add/>`。

```jsx
// Counter.js
import { useState } from "react";
import Add from "./Add";

function Counter() {
    let [num, setNum] = useState(0);
    const handleChange = (temp) => {
        setNum(temp);
    };

    return (
        <div>
            <span>计算结果： {num}</span>
            <Add num={num} onChange={handleChange}></Add>
        </div>
    );
}

// Add.js
function Add(props) {
    let num = props.num;
    const handleAdd = () => {
        props.onChange(num + 1);
    };
    return (
        <div>
            <button onClick={handleAdd}>点击 + 1</button>
        </div>
    );
}
```

在`Counter`组件中，我们把变量`num`和函数`handleChange`作为`props`传递给`Add`组件。在`Add`组件中接收了这两个参数，并且在内部调用`handleChange`函数来修改`num`的值。



### 状态提升

### 使用 ref 通信

在某些场景下，我们可能需要使用命令式的方式访问子组件。例如我们包装一个包含表单业务的弹窗组件，并在组件中
维护组件的显示和隐藏状态，然后在组件外部访问该组件内部的方法，控制该组件的显示隐藏。

幸运的是，`React`的组件提供了`ref`属性，允许我们访问组件实例。要实现这个功能，我们需要经过下面几个步骤。

1. 使用`useRef`创建组件引用。
2. 使用`forwardRef`包装子组件，把引用转发给子组件。
3. 使用`useImperativeHandle`自定义暴露给父组件的方法。

下面是一个简单的示例，演示了如何使用`ref`来实现组件之间的通信。

```jsx
import { useRef, useImperativeHandle, forwardRef } from "react";

const FancyInput = forwardRef((props, ref) => {
    const inputRef = useRef();

    useImperativeHandle(ref, () => ({
        focus: () => {
            inputRef.current.focus();
        },
    }));

    return <input ref={inputRef} {...props} />;
});

const MyComponent = () => {
    const fancyRef = useRef();

    const focusFancyInput = () => {
        fancyRef.current.focus();
    };

    return (
        <>
            <FancyInput ref={fancyRef} />
            <button onClick={focusFancyInput}>Focus Fancy Input</button>
        </>
    );
};
```

在上面的示例中，我们在父组件`MyComponent`组件中创建了`inputRef`，并访问了`FancyInput`组件的`focus`方法。
在子组件`FancyInput`中，使用`forwardRef`包装了子组件，把`inputRef`转发到组件内部， 然后使
用`useImperativeHandle`自定义了暴露给父组件的方法。

要实现子组件聚焦的功能，我们可以简单把`forwardRef`转发进来的`ref`参数传递给`<Input/>`。例如：

```jsx
const FancyInput = forwardRef((props, ref) => {
    return <input ref={ref} {...props} />;
});
```

但是我们在实际的业务过程中, 我们不可能总是仅仅访问子组件的`DOM`这么简单。

此外，我们在实际业务中，子组件可能对外暴露任何内部数据，因此对`useImperativeHandle`做个简单的说明：
它接收 3 个参数来控制暴露给父组件的方法。

```jsx
useImperativeHandle(ref, createHandle, [deps]);
```

-   `ref`
    通过`forwardRef`转发进来的父组件中传递的`ref`。
-   `createHandle`
    该函数的返回值是你想暴露的任何类型的数据，通常我们会返回一个对象，它会作为`ref.current`的值。
-   [deps]
    `createHandle`的依赖数组，依赖发生变化会重新执行 createHandle 函数。


## 跨级组件通信
### 使用 Context 通信

Context 是一个典型的生产者-消费者（Provider-Consumer）模式。当订阅了 Context 的消费者的组件，能从组件树中，离自己最近的生产者中获取值。Context 的使用包含创建和使用两个部分。我们先介绍 Context 的 API，然后再通过 Demo 说明如何使用 Context。

Context 的相关 API 包含下面几个：

-   React.createContext(defaultValue)

    通过调用该 API,就可以创建一个 Context 对象。defaultValue 是传入的默认值， 当订阅了 Context 消费者的组件，没有从树中匹配到生产者时，defaultValue 才会生效

    ```jsx
    const Context = React.createContext(defaultValue);
    ```

-   Conext.displayName

    Context 对象能够设置 display 属性，React DevTools 使用该字符串来确定 context 要显示的内容。

-   Context.Provider

    Provider 是 Context 对象上的生产者组件。使用 Provider 标签包裹的后代组件都能够访问到 Provider 组件传入的 value。

    ```jsx
    <Context.Provider value={/* 需要传给后代的值 */}>
        <ChildComponent></ChildComponent>
    </Context.Provider>
    ```

1. Provider 可以嵌套使用，但是同一个 Context 的 Provider 嵌套时，里层的值会覆盖外层的值。
2. Provider 能够监听到 value 值的变化，当 value 值变化时，它内部的所有消费者组件都会重新渲染。
3. 其实 value 传入的值也可以是对象，该对象可以包含一个回调函数，用来更新传入的值。

-   Context.Consumer

    Consumer 是一个消费者组件，此组件可以让你在函数式组件中可以订阅 context。但是这要求消费

    组件必须把一个函数作为子元素，这个函数接受 Provider 传入的值, 并返回一个 React 元素节点

    ```jsx
    function FunComponent() {
        return (
            <Context.Consumer>
                {(value) => {
                    return <div>{value}</div>;
                }}
            </Context.Consumer>
        );
    }
    ```

-   Class.contextType

    contextType 是自定义的类组件上的静态属性，可以被赋值为创建的 Context 对象，这样就可以在类组件内部通过`this.Context`来访问生产者传入的值。

    ```jsx
    class ClazzComponet extends React.Component {
        static contextType = Context;

        render() {
            const value = this.context;
            return <div>{value}</div>;
        }
    }
    ```

    当然，也可以在类外部赋值。

    ```jsx
    ClazzComponet.contextType = Context;
    ```

接下来我们通过一个 demo 演示 Context 的使用。

1. 创建 Context。

    ```jsx
    // Context.js
    import React from "react";

    const CounterContext = React.createContext({
        num: 0,
        handleChange: () => {},
    });

    CounterContext.displayName = "CounterContextName";

    export default CounterContext;
    ```

2. 在 Account 组件中添加一个 Provider 组件，将包含一个 num 变量及改变 num 变量的回调函数的对象，作为值传入其包裹的子组件及其后代。

    ```jsx
    import React from "react";
    import Counter from "./Counter";
    import CounterContext from "./Context";

    class Account extends React.Component {
        static contentType = CounterContext;

        constructor(props) {
            super(props);

            this.state = {
                num: 0,
            };
            this.handleChange = this.handleChange.bind(this);
        }

        handleChange(num) {
            this.setState({
                num,
            });
        }

        render() {
            const provider = {
                num: this.state.num,
                handleChange: this.handleChange,
            };

            return (
                <CounterContext.Provider value={provider}>
                    <Counter></Counter>
                </CounterContext.Provider>
            );
        }
    }

    export default Account;
    ```

3. 在 Counter 类组件中，订阅 Provider 传入的 value 值，并展示对象值的 num 变量。

    ```jsx
    import React from "react";
    import Add from "./Add";
    import CounterContext from "./Context";

    class Counter extends React.Component<any, any> {
        static contextType = CounterContext;

        constructor(props) {
            super(props);
        }

        render() {
            const { num } = this.context;

            return (
                <div>
                    <span>计算结果： {num}</span>
                    <Add num={num}></Add>
                </div>
            );
        }
    }

    export default Counter;
    ```

4. 在 Add 函数组件中，订阅 Provider 传入的 value 值，并通过传入的回调函数，更改值中的 num 变量。

    ```jsx
    import CounterContext from "./Context";

    function Add(props) {
        let num = props.num;
        return (
            <CounterContext.Consumer>
                {(context: any) => {
                    const { handleChange } = context;

                    return (
                        <button
                            onClick={() => {
                                handleChange(num + 1);
                            }}
                        >
                            点击 + 1
                        </button>
                    );
                }}
            </CounterContext.Consumer>
        );
    }

    export default Add;
    ```
