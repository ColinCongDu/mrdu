# 进程模型

在学习node.js的进程模型之前，我们先抛出几个问题:

1. node.js的进程模型和传统的多线程服务（Java、Apache、.NET）相比有什么区别？
2. 我们通常说node.js具有异步事件驱动、非阻塞IO、单线程的特点，所以node.js具有超强的高并发能力的优势。为什么异步IO就具有高并发的优势呢？
3. 为什么说node.js适合IO密集型任务，而不适合CPU密集型任务？
4. 既然node.js是单线程的，那它是如何实现高并发的呢？

带着这些问题，我们一步一步来分析node.js的进程模型。

## 传统服务器的进程模型

以Java Servlet 容器（Tomcat）、Apache HTTP Server（Prefork/Worker）、.NET ASP.NET Core Kestrel 为例，它们大多遵循”多进程+多线程（线程池）“的模型。

运行方式：
1. 每个请求需要一个**独立线程**来处理，如果有N个并发请求，就需要N个线程处理。
2. I/O是阻塞的，线程需要等待I/O操作(如数据库查询、文件读写等)完成，才能继续执行后续代码。

实现方式：
1. 进程模型：通常会有一个主进程监听端口，然后fork/启动多个 `worker` 进程。
2. 线程模型：每个 `worker` 进程内有一个线程池，用来分配给请求。

优点
1. 每个请求都有独立线程, 逻辑简单，不需要自己考虑事件循环。
2. 适合 CPU 密集型任务，多核利用率高。

缺点
1. 高并发时需要大量线程，线程上下文切换开销大。
2. 每个线程的栈内存占用（通常 512KB~1MB），1万并发就可能吃掉 10GB 内存。
3. 阻塞 I/O 会导致线程被挂起，降低吞吐。

## node.js的进程模型

Node.js 的进程模型是“单线程事件循环 + libuv 线程池 + 多进程扩展”，这种模型非常适合高并发 I/O 应用。

运行方式:
1. 不会为每个请求创建一个独立的线程，只有一个主线程处理请求，。所以有请求都在, 同一个事件循环（单线程） 中排队、调度。
2. 非阻塞I/O，所有的I/O操作都在`libuv`线程池（4个线程）中执行，不会阻塞主线程。
 
## Node.js 一个线程处理所有请求，会不会阻塞？

这是很多人第一次接触 Node.js 的时候最疑惑的地方。要分两种情况， 我们拆开来说。
### I/O 密集型请求（绝大多数 Web 应用）

- Node.js 主线程接到请求后，不会自己去做 I/O（例如读文件、查数据库、调用外部API）。
- 它会把这些耗时任务交给 libuv 的线程池 或 操作系统内核 去做。
- 主线程只负责记录一下“有个请求在等结果”，然后立刻去处理下一个请求。
- 当 I/O 完成时，结果会回调到事件循环，主线程再调用对应的回调函数。

所以即使有成千上万的并发请求，主线程也不会被阻塞，只是多了很多“待处理的回调”。
这就是Node.js可以轻松支撑10万级别并发连接的原因。

### CPU 密集型请求（例如计算、加密、压缩等）

- 如果主线程自己在跑耗时的 CPU 计算（比如循环处理大文件、加密、视频转码），
那么事件循环会被卡住，其他请求就得等。
- 这时 Node.js 的“单线程模型”确实会成为瓶颈。

这也就是为什么会说node.js适合IO密集型任务，而不适合CPU密集型任务的原因。

## 